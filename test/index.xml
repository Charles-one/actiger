<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tests on Actiger跳跳虎</title>
    <link>https://charles-one.github.io/actiger/test/</link>
    <description>Recent content in Tests on Actiger跳跳虎</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Jun 2019 23:59:47 +0800</lastBuildDate>
    
	<atom:link href="https://charles-one.github.io/actiger/test/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Moco示例</title>
      <link>https://charles-one.github.io/actiger/test/moco%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Sun, 16 Jun 2019 23:59:47 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/moco%E7%A4%BA%E4%BE%8B/</guid>
      <description> 1. Moco是什么? 简单的模拟服务器的程序库/工具, 有请求给出响应.下载中moco-runner-0.12.0-standalone.jar. 2. 使用示例 1. 创建test.json [ { &amp;quot;description&amp;quot;: &amp;quot;First test&amp;quot;, &amp;quot;request&amp;quot;: { &amp;quot;uri&amp;quot;: &amp;quot;/demo&amp;quot; }, &amp;quot;response&amp;quot;: { &amp;quot;text&amp;quot;: &amp;quot;First Response&amp;quot; } } ]  2. 命令行启动服务, moco-runner-0.12.0-standalone.jar与test.json在相同目录下.  java -jar ./moco-runner-0.12.0-standalone.jar http -p 8888 -c test.json  3. 验证 访问http://localhost:8888/demo </description>
    </item>
    
    <item>
      <title>TestNG生成测试报告</title>
      <link>https://charles-one.github.io/actiger/test/testng%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Sun, 16 Jun 2019 20:44:52 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</guid>
      <description>1. 使用的extentreports生成的测试报告, 报告中使用的css文件需要上强(墙) &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.aventstack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;extentreports&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  测试方法 package com.actiger.reports; import org.testng.Assert; import org.testng.Reporter; import org.testng.annotations.Test; public class TestReport { @Test public void test1(){ Assert.assertEquals(1,2); } @Test public void test2(){ Assert.assertEquals(1,1); } @Test public void test3(){ Assert.assertEquals(3,3); } @Test public void log1(){ Reporter.log(&amp;quot;这是日志&amp;quot;); throw new RuntimeException(&amp;quot;这是一个异常&amp;quot;); } }  配置的xml &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt; &amp;lt;suite name=&amp;quot;mytest&amp;quot;&amp;gt; &amp;lt;test name=&amp;quot;test&amp;quot;&amp;gt; &amp;lt;classes&amp;gt; &amp;lt;class name=&amp;quot;com.actiger.reports.TestReport&amp;quot;&amp;gt; &amp;lt;method&amp;gt; &amp;lt;include name=&amp;quot;test1&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;include name=&amp;quot;test2&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;include name=&amp;quot;test3&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;include name=&amp;quot;log1&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;/class&amp;gt; &amp;lt;/classes&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;listeners&amp;gt; &amp;lt;listener class-name=&amp;quot;com.</description>
    </item>
    
    <item>
      <title>TestNG超时测试</title>
      <link>https://charles-one.github.io/actiger/test/testng%E8%B6%85%E6%97%B6%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sun, 16 Jun 2019 14:00:18 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E8%B6%85%E6%97%B6%E6%B5%8B%E8%AF%95/</guid>
      <description> TestNG超时测试 超出预期时间则用例失败 package com.actiger.test.timeout; import org.testng.annotations.Test; public class TimeOut { @Test(timeOut = 3000) public void testSuccess() throws InterruptedException{ Thread.sleep(2000); } @Test(timeOut = 2000) public void testFail() throws InterruptedException{ Thread.sleep(3000); } }  </description>
    </item>
    
    <item>
      <title>TestNG多线程配置</title>
      <link>https://charles-one.github.io/actiger/test/testng%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 16 Jun 2019 00:46:00 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE/</guid>
      <description>1. 在方法注释中配置多线程, 配置线程池  package com.actiger.test.thread; import org.testng.annotations.Test; public class MultiThread { @Test(invocationCount = 10, threadPoolSize = 3) public void test(){ System.out.println(&amp;quot;1&amp;quot;); System.out.println(&amp;quot;Thread ID:%s%n&amp;quot; + Thread.currentThread().getId()); } }  2. 在xml中配置多线程, 不可配置为线程池. package com.actiger.test.thread; import org.testng.annotations.Test; public class MultiThreadOnXml { @Test public void test1(){ System.out.println(&amp;quot;Thread ID: &amp;quot; + Thread.currentThread().getId()); } @Test public void test2(){ System.out.println(&amp;quot;Thread ID: &amp;quot; + Thread.currentThread().getId()); } @Test public void test3(){ System.out.println(&amp;quot;Thread ID: &amp;quot; + Thread.currentThread().getId()); } }  multiThread.</description>
    </item>
    
    <item>
      <title>TestNG参数化测试</title>
      <link>https://charles-one.github.io/actiger/test/testng%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sat, 15 Jun 2019 17:35:15 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
      <description>1. 参数化测试, 使用DataProvider来参数化. @Test中dataProvider的名字与@DataProvider名称一致  @Test(dataProvider = &amp;quot;data&amp;quot;) public void dataProvider(String name, int age){ System.out.println(&amp;quot;Name:&amp;quot; + name + &amp;quot;, &amp;quot; + &amp;quot;Age:&amp;quot; + age); } @DataProvider(name = &amp;quot;data&amp;quot;) public Object[][] data(){ Object[][] oo = new Object[][]{ {&amp;quot;zhangsan&amp;quot;, 18}, {&amp;quot;lisi&amp;quot;, 20}, {&amp;quot;wangwu&amp;quot;, 30} }; return oo; }  2. 针对不方法识别, 使用不同参数  @Test(dataProvider = &amp;quot;testMethod&amp;quot;) public void method1(String name, int age){ System.out.println(&amp;quot;Name:&amp;quot; + name + &amp;quot;, &amp;quot; + &amp;quot;Age:&amp;quot; + age + &amp;quot;1111&amp;quot;); } @Test(dataProvider = &amp;quot;testMethod&amp;quot;) public void method2(String name, int age){ System.</description>
    </item>
    
    <item>
      <title>TestNG依赖测试和xml文件参数化</title>
      <link>https://charles-one.github.io/actiger/test/testng%E4%BE%9D%E8%B5%96%E6%B5%8B%E8%AF%95%E5%92%8Cxml%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E5%8C%96/</link>
      <pubDate>Thu, 13 Jun 2019 23:19:11 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E4%BE%9D%E8%B5%96%E6%B5%8B%E8%AF%95%E5%92%8Cxml%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E5%8C%96/</guid>
      <description>1. TestNG依赖测试, 1个用例依赖其他的测试方法, 怎么表示这种关系呢, 在注解后加标签dependsOnMethods 例如, 方法2就依赖于方法1, 如果方法1执行失败了, 方法2就无法执行了.  package com.actiger.test.all; import org.testng.annotations.Test; public class Dependon{ @Test public void dependon1(){ System.out.println(&amp;quot;dependon 1111111&amp;quot;); throw new RuntimeException(); } @Test(dependsOnMethods = {&amp;quot;dependon1&amp;quot;}) public void dependon2(){ System.out.println(&amp;quot;dependon 2222222&amp;quot;); } }  2. TestNG的xml文件参数化 1.创建方法 package com.actiger.test.paramter; import org.testng.annotations.Parameters; import org.testng.annotations.Test; public class ParamterTest { @Test @Parameters({&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;}) public void paramTest1(String name, int age){ System.out.println(&amp;quot;Name:&amp;quot;+ name + &amp;quot;, &amp;quot; + &amp;quot;Age:&amp;quot; + age); } }  2.</description>
    </item>
    
    <item>
      <title>TestNG异常测试</title>
      <link>https://charles-one.github.io/actiger/test/testng%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 12 Jun 2019 23:07:19 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95/</guid>
      <description> TestNG异常测试 1. expectedException方法预期RuntimeException异常 2. expectedSuccess方法预期RuntimeException异常 3. expectedException用例结果是失败的, expectedSuccess执行用例成功(预期与结果一致) package com.actiger.test.expectedException; import org.testng.annotations.Test; public class ExpectedExcepiton { @Test(expectedExceptions = RuntimeException.class) public void expectedException(){ System.out.println(&amp;quot;期望运行异常的结果!&amp;quot;); } @Test(expectedExceptions = RuntimeException.class) public void expectedSuccess(){ System.out.println(&amp;quot;期望运行异常的结果&amp;quot;); throw new RuntimeException(); } }  </description>
    </item>
    
    <item>
      <title>TestNG中注解Before After执行顺序</title>
      <link>https://charles-one.github.io/actiger/test/testng%E4%B8%AD%E6%B3%A8%E8%A7%A3before-after%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Wed, 12 Jun 2019 11:12:12 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/testng%E4%B8%AD%E6%B3%A8%E8%A7%A3before-after%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid>
      <description>1. TestNG是什么 TestNG一种开源自动测试框架, 相当灵活的注解和配置, 自由测试. 2. Before After执行顺序    注解 描述     @BeforeSuite 套件, 在所有测试开始时运行1次   @BeforeTest 在所有类Classes前, BeforeSuite后运行1次,注解的方法将在testNG.xml文件test标签内的所有类方法运行前执行   @BeforeClass 在单个class类前执行1次   @BeforeGroups 在所有配置方法组前运行1次   @BeforeMethod 在单个配置方法前运行   @AfterMethod 在单个配置方法后运行   @AfterGroups 在所有配置方法组后运行1次   @AfterClass 在单个class类后执行1次   @AfterTest 在所有类Classes后, AfterSuite前运行1次, 注解的方法将在testNG.xml文件test标签内的所有类方法运行后执行。   @AfterSuite 套件, 在所有测试结束时运行1次    package com.actiger.test.suite; import org.testng.annotations.*; public class LoginTest { @Test(groups = {&amp;quot;group&amp;quot;}) public void loginTest(){ System.</description>
    </item>
    
    <item>
      <title>Jmeter性能测试并添加服务器cpu内存使用率</title>
      <link>https://charles-one.github.io/actiger/test/jmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87/</link>
      <pubDate>Thu, 14 Mar 2019 23:31:20 +0800</pubDate>
      
      <guid>https://charles-one.github.io/actiger/test/jmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87/</guid>
      <description>0. 准备工作  搭建静态博客Hugo, 建立Hugo服务作为测试接口 服务端centOS7.6.1810, 服务端ServerAgent 本机安装Java8, 并设置环境变量 本机jmeter, jmeter插件管理, Servers Performance Monitoring插件  1.服务端CentOS7 搭建Hugo, 并建立Hugo服务, 创建接口.  搭建Huog  请参考这个搭建Hugo文章
参考到这条语句下就可以了,这条语句下面的内容不用看了
hugo server --theme=hugo-paper --bind=“10.211.55.9即是你的ip(不指定则默认只能本地访问)” --baseUrl=“http://10.211.55.9&amp;quot; --port=1313   创建接口
hugo server --theme=hugo-paper --bind=“10.211.55.9即是你的ip(不指定则默认只能本地访问)” --baseUrl=“http://10.211.55.9&amp;quot; --port=1313  检测服务端接口
  在浏览器中访问 http://你的ip:1313.如未指定,则是http://localhost:1313
能正常访问显示文章就完成了
2. 本机下载jmeter, jmeter插件管理, Servers Performance Monitoring插件  下载地址Jmeter, 安装插件  Jmeter下载地址
下载并解压
Jmeter插件管理
下载并解压出对应jar文件, 并放在apache-jmeter-5.1/lib/ext中
关闭Jmeter, 再重新打开Jmeter
进入选项(Options)-&amp;gt;插件管理(Plugins Manager)中
搜索perfmon并安装
3. 服务端下载PerfMon Server Agent运行, 添加防火墙端口4444  下载PerfMon Server Agent</description>
    </item>
    
  </channel>
</rss>